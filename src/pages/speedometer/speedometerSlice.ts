import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../../store/store';

export interface ILocation {
	latitude: number;
	longitude: number;
	altitude: number;
	speed: number;
	heading: number;
	climb: number;
	error: {
		latitude: number;
		longitude: number;
		altitude: number;
		speed: number;
		heading: number;
	};
}

export interface IWeather {
	temperature: number;
	temperatureMin: number;
	temperatureMax: number;
	feelsLike: number;
	description: string;
	icon: string;
	rain: number;
	snow: number;
	windSpeed: number;
	windDirection: number;
	humidity: number;
	pressure: number;
	visibility: number;
	sunrise: number;
	sunset: number;
	city: string;
	timezone: number;
}

export interface ISpeedometerState {
	speed: number;
	rpm: number;
	fuel: number;
	oilTemperature: number;
	oilPressure: number;
	voltage: number;
	headlights: number;
	turnSignal: boolean;
	checkEngine: boolean;
	location: ILocation;
	weather: IWeather;
	startTime: number;
}

const initialState: ISpeedometerState = {
	speed: 0,
	rpm: 0,
	fuel: 0,
	oilTemperature: 0,
	oilPressure: 0,
	voltage: 0,
	headlights: 0,
	turnSignal: false,
	checkEngine: false,
	location: {
		latitude: 0,
		longitude: 0,
		altitude: 0,
		speed: 0,
		heading: 0,
		climb: 0,
		error: {
			latitude: 0,
			longitude: 0,
			altitude: 0,
			speed: 0,
			heading: 0,
		},
	},
	weather: {
		temperature: 0,
		temperatureMin: 0,
		temperatureMax: 0,
		feelsLike: 0,
		description: '',
		icon: '',
		rain: 0,
		snow: 0,
		windSpeed: 0,
		windDirection: 0,
		humidity: 0,
		pressure: 0,
		visibility: 0,
		sunrise: 0,
		sunset: 0,
		city: '',
		timezone: 0,
	},
	startTime: Date.now(),
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//   'counter/fetchCount',
//   async (amount: number) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

export const speedometerSlice = createSlice({
	name: 'speedometer',
	initialState,
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		setSpeed: (state, action: PayloadAction<number>) => {
			state.speed = action.payload;
		},
		setRPM: (state, action: PayloadAction<number>) => {
			state.rpm = action.payload;
		},
		setFuel: (state, action: PayloadAction<number>) => {
			state.fuel = action.payload;
		},
		setOilTemp: (state, action: PayloadAction<number>) => {
			state.oilTemperature = action.payload;
		},
		setOilPressure: (state, action: PayloadAction<number>) => {
			state.oilPressure = action.payload;
		},
		setVoltage: (state, action: PayloadAction<number>) => {
			state.voltage = action.payload;
		},
		setHeadlights: (state, action: PayloadAction<number>) => {
			state.headlights = action.payload;
		},
		setTurnSignal: (state, action: PayloadAction<boolean>) => {
			state.turnSignal = action.payload;
		},
		setCheckEngine: (state, action: PayloadAction<boolean>) => {
			state.checkEngine = action.payload;
		},
		setLocation: (state, action: PayloadAction<ILocation>) => {
			state.location = action.payload;
		},
		setWeather: (state, action: PayloadAction<IWeather>) => {
			state.weather = action.payload;
		},
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	// extraReducers: (builder) => {
	//   builder
	//     .addCase(incrementAsync.pending, (state) => {
	//       state.status = 'loading';
	//     })
	//     .addCase(incrementAsync.fulfilled, (state, action) => {
	//       state.status = 'idle';
	//       state.value += action.payload;
	//     })
	//     .addCase(incrementAsync.rejected, (state) => {
	//       state.status = 'failed';
	//     });
	// },
});

export const {
	setSpeed,
	setRPM,
	setFuel,
	setOilTemp,
	setOilPressure,
	setVoltage,
	setHeadlights,
	setTurnSignal,
	setCheckEngine,
	setLocation,
	setWeather,
} = speedometerSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectSpeedometer = (state: RootState) => state.speedometer;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
//   (amount: number): AppThunk =>
//   (dispatch, getState) => {
//     const currentValue = selectCount(getState());
//     if (currentValue % 2 === 1) {
//       dispatch(incrementByAmount(amount));
//     }
//   };

export default speedometerSlice.reducer;
